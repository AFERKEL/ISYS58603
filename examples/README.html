<h1 id="examples">Examples</h1>
<p>This folder contains examples which can provide guidance for some of the assignments. Please keep in mind Academic Integrity guidelines when using these examples.</p>
<h2 id="contents">Contents</h2>
<h3 id="basic-flask.py">basic-flask.py</h3>
<p>This is an example of how to write an API using Flask. This example shows how to get/post and delete customers from the chinook database. In order to run this example, you will need to install the following packages: * flask</p>
<p>Once you have installed the packages, you can run the example by executing the following command: <code>python flask-example.py</code></p>
<p>With the application running in a terminal, you’ll need to connect to the application using an endpoint such as web browser or Postman. The following endpoints are available: * http://localhost:5000/customers - GET - Returns a list of all customers * http://localhost:5000/customers/{id} - GET - Returns a single customer by id * http://localhost:5000/customers - POST - Creates a new customer * http://localhost:5000/customers/{id} - DELETE - Deletes a customer by id * http://localhost:5000/customers - PUT - Updates a customer</p>
<p>At the top of file you will see some boiler plate setup code</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>app <span class="op">=</span> Flask(<span class="va">__name__</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>DB_PATH <span class="op">=</span> Path.cwd() </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>DATABASE_FILE <span class="op">=</span> DB_PATH <span class="op">/</span> <span class="st">&#39;examples&#39;</span><span class="op">/</span><span class="st">&#39;chinook.db&#39;</span></span></code></pre></div>
<p>The first line creates an instance of the Flask application. The second line creates a variable that contains the path to the database. The third line creates a variable that contains the path to the database file. The database file is in the examples folder and is called chinook.db. The chinook database is a sample database that is used in many examples. You can find more information about the chinook database <a href="https://www.sqlitetutorial.net/sqlite-sample-database/">here</a></p>
<p>Following this we show the routes that are supported by the Flask app</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="at">@app.route</span>(<span class="st">&#39;/&#39;</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="kw">def</span> index():</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    <span class="cf">return</span> <span class="st">&#39;Hello World!&#39;</span></span></code></pre></div>
<p>The first example says, if there is a request like http://localhost:5000/, then call the function <code>index()</code>. This function returns the string <code>Hello World!</code>. The second example is a little more complicated.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="at">@app.route</span>(<span class="st">&#39;/customers&#39;</span>, methods<span class="op">=</span>[<span class="st">&#39;GET&#39;</span>])</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="kw">def</span> get_customers():</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    ...</span></code></pre></div>
<p>This code tells Flash when it sees a request like http://localhost:5000/customers, it should call the function <code>get_customers()</code>. The <code>methods=['GET']</code> tells Flask that this route only supports the GET method. If you wanted to support multiple methods, you would add them to the list like this <code>methods=['GET', 'POST']</code>. The <code>@app</code> is a decorator that tells Flask that the function that follows is a route handler.</p>
<p>As you progress, you’ll see other routes and verbs are all broken down into unique methods. This is a good practice to follow as it makes the code easier to read and maintain.</p>
<p>Following the route handlers, you’ll see functions which work directly with the database. You’ve written some of this code already when you wrote the previous assignment on database querying. For simplicity, I’ve broken down each database query into it’s own function - but this is not required if you can find a way to collapse common functionality into a single function. Also notice that it is unwise to include both the controller (the routes) and the model code (the database query functions) in the same file. This is done here for simplicity, but in a real application, you would want to separate these into different files.</p>
<p>At the very bottom of the file, you’ll see the following code:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&#39;__main__&#39;</span>:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>    <span class="co"># This says: if this file is run directly, then run the Flask app</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>    app.run(debug<span class="op">=</span><span class="va">False</span>, use_reloader<span class="op">=</span><span class="va">False</span>, passthrough_errors<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<p>This code just says, if you execute the file directly (using <code>python basic-flask.py</code>), then run the Flask app. If you import this file into another file, then this code will not execute. This is a common pattern in Python.</p>
<h3 id="advanced-flask.py">advanced-flask.py</h3>
<p>In the advanced-flask example, we add a few more features. To keep the code to a minimum, we haven’t added any of the functionality from the basic-flask example. Instead, we’ve added a few more features that you might find useful.</p>
<h4 id="start-and-limit-parameters">start and limit parameters</h4>
<p>The first feature we’ve added is the ability to specify a start and limit parameter. This allows you to page through the results. For example, if you wanted to get the first 10 customers, you would use the following URL:</p>
<pre><code>https://localhost:5000/customers?limit=10</code></pre>
<p>If you wanted to get the next 10 customers, you would use the following URL:</p>
<pre><code>https://localhost:5000/customers?start=10&amp;limit=10</code></pre>
<p>Notice that the start parameter is 0 based. So the first 10 customers are returned when start=0 and limit=10. The next 10 customers are returned when start=10 and limit=10. The next 10 customers are returned when start=20 and limit=10. And so on.</p>
<p>This is a very common pattern in REST APIs. It allows you to page through the results. You can also use this pattern to implement infinite scrolling in a web application. Additionally, it is helpful to limit the results provided by the API. This prevents the API from returning too much data and overwhelming the client. This can be done by setting a reasonable limit in the API itself.</p>
<h4 id="nested-results">Nested results</h4>
<p>The second feature we’ve added is the ability to return nested results. For example, if you wanted to get a list of all invoices and their invoice details, you would use the following URL:</p>
<pre><code>https://localhost:5000/invoices</code></pre>
<p>This requires a table join for the results, but then we have to manually unwind the single record we get for each invoice into multiple records.</p>
<h4 id="advanced-syntax">Advanced syntax</h4>
<p>When using long strings in our code, like SQL statements, it can be helpful to use the triple quote syntax. This allows you to write the string on multiple lines. For example, the following two statements are equivalent:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>sql <span class="op">=</span> <span class="st">&quot;SELECT * FROM customers&quot;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>sql <span class="op">=</span> <span class="st">&quot;&quot;&quot;SELECT * </span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="st">         FROM customers</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="st">      &quot;&quot;&quot;</span></span></code></pre></div>
<p>The second example is easier to read and maintain. This is especially true when you have a long SQL statement.</p>
<h4 id="error-handling">Error handling</h4>
<p>In the advanced example, we’ve added some basic error handling. This is a good practice to follow. It is important to return the correct HTTP status code when an error occurs. This allows the client to handle the error appropriately. For example, if the client receives a 404 status code, it knows that the resource it requested was not found. If the client receives a 500 status code, it knows that an internal server error occurred. The client can then handle the error appropriately.</p>
<p>In our case, we provide a InvalidAPIUsage exception which is raised when an error occurs. This exception takes a message and a status code. The message is returned to the client as part of the response. The status code is used to set the HTTP status code. This allows us to return a 404 status code when a resource is not found, a 500 status code when an internal server error occurs, and so on.</p>
